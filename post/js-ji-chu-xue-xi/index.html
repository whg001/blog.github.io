<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JS基础学习 | haogui</title>
<link rel="shortcut icon" href="https://whg001.github.io/favicon.ico?v=1639306896551">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://whg001.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JS基础学习 | haogui - Atom Feed" href="https://whg001.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="最近由于换公司了，相应语言有改变。本博客为基础es6的学习
基本语法
var,let,const
三个都是声明变量，var作用域为全局，let为对应的方法块。
var的变量在运行时可能会出现undefined，比如在初始化之前使用，可以重复..." />
    <meta name="keywords" content="js" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://whg001.github.io">
  <img class="avatar" src="https://whg001.github.io/images/avatar.png?v=1639306896551" alt="">
  </a>
  <h1 class="site-title">
    haogui
  </h1>
  <p class="site-description">
    人得自个成全自个
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="https://whg001.github.io/post/java-xian-cheng-chi" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JS基础学习
            </h2>
            <div class="post-info">
              <span>
                2021-10-24
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://whg001.github.io/tag/epTCQykWR/" class="post-tag">
                  # js
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://whg001.github.io/post-images/js-ji-chu-xue-xi.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>最近由于换公司了，相应语言有改变。本博客为基础es6的学习</p>
<h3 id="基本语法">基本语法</h3>
<p>var,let,const</p>
<p>三个都是声明变量，var作用域为全局，let为对应的方法块。</p>
<p>var的变量在运行时可能会出现undefined，比如在初始化之前使用，可以重复var变量名相同。</p>
<p>let的变量如果在其作用域之外使用，由于他不存在，就会抛出一个错误，在同一作用域内不能let变量名相同的。</p>
<p>const为一个常量，一旦声明变量，就必须立即初始化，不能留到以后赋值。只在声明所在的块级作用域内有效。const是其引用不能改变，与java的final一致</p>
<p><strong>var的变量在其声明前可以使用原因</strong>：js在加载时会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值。</p>
<p>如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<h3 id="promise">promise</h3>
<p>promise一个异步的操作，并包含回调函数，回调函数都是可选的。<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。并且会将里面的参数传入<code>.then</code>的回调方法中例如</p>
<pre><code class="language-js">const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
</code></pre>
<p>promise.then(()-&gt;{},()-&gt;{})，2个函数都是可选的，resolve(表示成功进入到.then的第一个方法里)与reject(代表失败进入到.then的第二个方法里)的参数会带入对应的方法里面去，这一类返回的的都是新的promise，可以使用新的箭头函数</p>
<p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><strong>promise.all()，相同于CountDownLatch</strong></p>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。相当于一个同步器类似countdownlatch。<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数(<strong>所以一个rejected，则会进入到then，而不会等待其全部运行结束</strong>)。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<p><strong>Promise.race()</strong></p>
<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。只要promise之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数</p>
<p><strong>Promise.any()</strong></p>
<p><code>Promise.any()</code>方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
<h3 id="迭代器iterator">迭代器iterator</h3>
<p>迭代器模式，用于提供一致性遍历，提供统一性遍历接口规范，让其只关注于元素的遍历。js中只需在prototype中添加Symbol.iterator方法，并实现next()，<code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p>
<p>对比java中的他将用于判断是否还能继续遍历的hasNext()方法放入了 next()的返回值中，进行判断。</p>
<p>for of的循环语法糖，通过迭代器进行了判断</p>
<pre><code class="language-js">function Obj(value) {
    this.value = value;
    this.next = null;
  }

Obj.prototype[Symbol.iterator] = function() {
    var iterator = { next: next };

    var current = this;

    function next() {
        if (current) {
        var value = current.value;
        current = current.next;
        return { done: false, value: value };
        }
        return { done: true };
    }
    return iterator;
}

var one = new Obj(1);
var two = new Obj(2);
var three = new Obj(3);

one.next = two;
two.next = three;
let iterator = one[Symbol.iterator]();
iterator.next();
iterator.next();
let temp = iterator.next();
console.log(temp);
</code></pre>
<p><strong>使用了迭代器的语法</strong></p>
<p>for of 遍历对象时默认调用他的Iterator</p>
<p>扩展运算符（...）也会调用默认的 Iterator 接口</p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<p><strong>迭代器中的return()</strong></p>
<p>Js迭代器中next()方法是必须的，而return()方法则是可选的。<code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p>
<p>例如</p>
<pre><code class="language-js">function readLinesSync(file) {
  return {
    [Symbol.iterator]() {
      return {
        next() {
          return { done: false };
        },
        return() {
          file.close();
          return { done: true };
        }
      };
    },
  };
}
</code></pre>
<h4 id="基本语法-2">基本语法</h4>
<p><em><em>格式：function</em> &lt;函数名&gt;</em>*</p>
<pre><code class="language-js">function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
hw.next() //得到的值 { value: 'hello', done: false }
hw.next() //得到的值 { value: 'world', done: false }
hw.next() //得到的值 { value: 'ending', done: true }
hw.next() //得到的值 { value: 'undefined', done: true }
g.return('foo') // { value: &quot;foo&quot;, done: true }

</code></pre>
<p>第一次调用next()，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止(遇到yield就会暂停，调用next继续往下执行)。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>Generator 函数返回的遍历器对象，还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>
<p>如果没有yeild这个函数就相当于一个暂缓函数。</p>
<p>调用next时，如果将参数代入进去则会给yield的调用者赋值,没传值的话接受yield则默认是undefined，如下代码与注释所示</p>
<pre><code class="language-js">function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false},因为没有传值则var y = 2 * undefined
a.next() // Object{value:NaN, done:true}

console.log(&quot;------&quot;);

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }，因为没有传值则var y = 2 * 12
b.next(13) // { value:42, done:true }
</code></pre>
<h4 id="generatorprototypethrow"><strong>Generator.prototype.throw()</strong></h4>
<p>可以在函数体外抛出错误，然后在 Generator 函数体内捕获。例如</p>
<pre><code class="language-js">var g = function* () {
    try {
      console.log(&quot;gogogo &quot;)
      yield;
    } catch (e) {
      console.log('内部捕获', e);
    }
  };

  
var i = g();
i.next();
console.log(&quot;准备throw &quot;)
try {
  i.throw('a');
  i.throw('b');
} catch (e) {
	console.log('外部捕获', e);
}
// gogogo 
// 准备throw 
// 内部捕获 a
// 外部捕获 b

// 抛出了2个错误，一次被generator捕获，一次被外部函数捕获
</code></pre>
<h4 id="next-throw-return-的共同点">next()、throw()、return() 的共同点</h4>
<p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p>
<p><code>next()</code>是将yield换成一个值，如果没有传递值则是一个<code>undefined</code></p>
<p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句</p>
<p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句</p>
<h3 id="async函数">async函数</h3>
<p>todo 阅读 https://juejin.cn/post/6844903891021086734</p>
<p><code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已</p>
<p><code>async</code>函数对 Generator 函数的改进，如下</p>
<ol>
<li>内置执行器。调用函数只需要<code>函数名()</code>即可调用，不需要<code>.next()</code></li>
<li><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</li>
</ol>
<p>await的方法如果reject，则会进入.then()方法，会导致其后的await可能未执行，若想其全部执行可以将会出现await的放入try catch中</p>
<p>例如</p>
<pre><code class="language-js">const superagent = require('superagent');
const NUM_RETRIES = 3;

async function test() {
  let i;
  for (i = 0; i &lt; NUM_RETRIES; ++i) {
    try {
      await superagent.get('http://google.com/this-throws-an-error');
      break;
    } catch(err) {}
  }
  console.log(i); // 3
}

test();
</code></pre>
<p><strong>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</strong></p>
<pre><code class="language-JS">let foo = await getFoo();
let bar = await getBar();
</code></pre>
<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<p>下面写法可以让这2个异步的操作同时进行</p>
<pre><code class="language-JS">// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;
</code></pre>
<p>一组异步操作，需要按照顺序完成，进行同步获取url链接，或者异步获取示例代码。</p>
<pre><code class="language-js">// 同步运行async function logInOrder(urls) {  for (const url of urls) {    const response = await fetch(url);    console.log(await response.text());  }}// 异步运行async function logInOrder(urls) {  // 并发读取远程URL  const textPromises = urls.map(async url =&gt; {    const response = await fetch(url);    return response.text();  });  // 按次序输出  for (const textPromise of textPromises) {    console.log(await textPromise);  }}
</code></pre>
<h3 id="类">类</h3>
<p>在es的class中必须有构造函数(constructor),如果没有他会默认添加一个无参数的构造函数。</p>
<p>ES6 的类，完全可以看作<strong>构造函数的另一种写法</strong>。</p>
<pre><code class="language-js">class Point {  // ...}typeof Point // &quot;function&quot;Point === Point.prototype.constructor // true
</code></pre>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。因此，在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<pre><code class="language-js">class B {}const b = new B();b.constructor === B.prototype.constructor // true
</code></pre>
<p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>
<p>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</p>
<pre><code class="language-js">class MyClass {  constructor() {    // ...  }  get prop() {    return 'getter';  }  set prop(value) {    console.log('setter: '+value);  }}let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter'
</code></pre>
<p>采用 Class 表达式，可以写出立即执行的 Class。</p>
<pre><code class="language-js">let person = new class {  constructor(name) {    this.name = name;  }  sayName() {    console.log(this.name);  }}('张三');person.sayName(); // &quot;张三&quot;
</code></pre>
<p><strong>class 的name属性</strong></p>
<p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>
<pre><code class="language-js">class Point {}Point.name // &quot;Point&quot;
</code></pre>
<p><strong>static,静态方法</strong></p>
<p>与类绑定，<strong>不能通过实例调用</strong>，注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。父类的静态方法，可以被子类继承。</p>
<p>其也拥有过静态属性，添加static即可</p>
<p>dig 域名看其环境</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></li>
<li><a href="#promise">promise</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8iterator">迭代器iterator</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2">基本语法</a></li>
<li><a href="#generatorprototypethrow"><strong>Generator.prototype.throw()</strong></a></li>
<li><a href="#next-throw-return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">next()、throw()、return() 的共同点</a></li>
</ul>
</li>
<li><a href="#async%E5%87%BD%E6%95%B0">async函数</a></li>
<li><a href="#%E7%B1%BB">类</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://whg001.github.io/post/die-dai-qi/">
              <h3 class="post-title">
                迭代器
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'b908b3d493434141cd44',
    clientSecret: '3bac7117ff4b3e75eb306e29708aef5a65fb483d',
    repo: 'blog-comments',
    owner: 'whg001',
    admin: ['whg001'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  转载请著名出处
  <a class="rss" href="https://whg001.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
